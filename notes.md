## Overview

Alice wants to send a message to Bob

- Eve overhears the message
- Adam and Bob don't want Eve to be able to decode it

**Information-Theoretic Security**: Eve doesn't have enough information to crack the message, even with unlimited computation power

**Computation Security**: Eve is computationally limited (e.g. can't factor quickly)

Steps for any cipher

- Remove spaces and make blocks of $5$ characters
- Make all letters capital
- Remove punctuation
- Can extend alphabet to accept numbers

## Modular Arithmetic (Abbreviated)

$x \equiv y \pmod{n}$ if and only if $n \mid x - y$

Modular division: we want a number such that $xy \equiv 1 \pmod n$

  - Will only exist if $x, y$ are coprime

## Shift Cipher

$M$ = all English texts, **Message Space**

$S$ = $\{0, \ldots, 25\}$, **Key Space**

Enc$(M, s) = (m_1 + s, m_2 + s, \ldots)$

Dec$(C, s) = (c_1 - s, c_2 - s, \ldots)$

### Cracking Shift Cipher

One thing to note is that Shift has a **small keyspace** so we can brute force all 26 keys

```
Input T
For s = 0 to 25
  Generate T + s
  Look at result and test if it looks English
```

However, this is extremely tedious. Instead we use **letter frequencies**

Let $T$ be a long text of length $N$

Let $N_a$ be the number of $a \in T$, $N_b$ be the number of $b \in T, \ldots$

We define a frequency vector $f_T = (\frac{N_a}{N}, \frac{N_b}{N}, \ldots, \frac{N_z}{N})$ and define the following algorithm:

**IsEnglish**

Let $f_E$ be the frequency vector of English

Let $f_T$ be the frequency vector of $T$

Note that taking the dot product, only $f_E \cdot f_E$ will be large $(\approx 0065)$, and all other dot products will be small $(\approx 0.038)$

```
Input T
Compute f_T
Compute f_E⋅f_T and if ~ 0.065 YES else NO
```

Turning back to cracking shift, the overall algorithm is

```
Input T
For s = 0 to 25
  Create T_s
  If IsEnglish(T_s) = YES then STOP
```

## Kerkhoff's Principle
We assume that

- Eve knows the encryption scheme
- Eve knows the alphabet and language
- Eve doesn't know the key
- Key is chosen randomly

## Private Key Encryption

$M$ is the message space

Generate a key $k \in K$

Enc(m)

Dec(m)

**Note**: we must have that $(\forall m \in M)$[Dec(Enc($m$)) = $m$]

## Affine Cipher

$K = \{(a,b) \mid 0 \leq a, b \leq 25 \text{ and } a \text{ rel prime 26}|\}$

Encrypt: $x \rightarrow ax +b \pmod{26}$

Decyrpt: $x \rightarrow a^{-1}(x - b) \pmod{26}$

Only requirement is that we need $\gcd(a, 26) = 1$ so that $a^{-1}$ exists

### Cracking Affine Cipher

```
Input T, a long English text
For all (a,b) in K:
  Apply ax + b to T and obtain T_{a,b}
  Let f_{a,b} be the frequency vector of T_{a,b}
  Compute f_E⋅f_{a,b}
The answer will the (a,b) pair that maximizes the dot product
```

## Quadratic Cipher

$K = \{(a, b, c) \mid 0 \leq a,b,c \leq 25\}$

Encrypt: $x \rightarrow ax^2 + bx + c$

Main issue is that we need to ensure that $f(x)$, with $a,b,c$ has an inverse, but this is hard b/c we need to test each individual $f(0) \ldots f(25)$

## General Sub Cipher and Random Looking Cipher
Idea is to take a permutation of $\{0, \ldots, 25\}$ as the key

Enc: $x \rightarrow f(x)$

Dec: $x \rightarrow f^{-1}(x)$

### Random Looking Cipher (Keyword Shift Cipher)

Generating a completely random permutation can be difficult, so instead we want to create a random looking permutation

For **Keyword Shift Cipher**, the key is (phrase, shift)

The permutation is generated by 
  - writing out phrase (removing duplicate letters)
  - horizontally shifting the text by `shift`

Main concern is that for a small phrase, there are a long sequence of consecutive letters

### Cracking General Substitution

Let $\sigma$ be a permutation and $T$ be a text

- $f_E$ is the frequency of $n$-grams, a $26^n$ long vector
- $\sigma(T)$ is taking $T$ and applying $\sigma$ to it
- $f_{\sigma(T)}$ is a $26^n$ frequency vector for $\sigma(T)$
- Use $I, R$ as parameters
- We compare permutations $\sigma_i$ and $\sigma_j$ by seeing which one looks more like English

```
Let σ_{init} be a permutation that maps 'e' to the most frequent letter

for r = 1 to R (small)
  σ_r = σ_{init}
  for i = 1 to I (large)
    pick j, k in {0, ..., 25} random
    let σ' be σ_r with j, k swapped
    if f_{σ'} produces a better frequency than f_{σ}
      σ_r = σ'
pick σ_r with the best result and have a human look at σ_r(T)
```

## Vigenere Cipher
Key is a word or phrase: $k = (k_1, k_2, \ldots, k_n)$

Enc$(m, k)$ = $m_1 + k_1, \ldots, m_n + k_{n}, m_{k+1} + k_1 \ldots$

Enc$(c, k)$ = $c_1 - k_1, \ldots, c_n - k_{n}, c_{k+1} - k_1 \ldots$

There are 3 main types of vig ciphers:

- Standard: key is a short phrase
- Book: use an entire book as the key
- One time pad: extremely long set of random bits that can't be exhausted

### Cracking Vigenere Cipher
First we find the length of the key $L$. We assume that a word that appears frequently will likely appear in the same position $i \pmod{L}$

- For example is "aiq" appears in the slots (57, 58, 59), (87, 88, 89), (102, 103, 104), (162, 163, 164), we can deduce that the length of the key is a divisor of the gaps between these sequences, $L = \{1, 3, 5, 15\}$

This will create a stream of every $L$th character. We can do shift analysis on these streams

### One Time Pad
We encode messages with a long string of random bits

$M = \{0, 1\}^n$

Gen $K = \{0, 1\}^n$

Enc$(m,k) = k \oplus m$

Dec $(c, k) = k \oplus k$

## Psuedo Random Bits
Creating pure random bits is hard for One Time Pad. Instead we produce a string a random looking bits using **Linear Congruential Generator**

Pick $M$ large and $A, B, x_0$ that are random looking. Then we can create a recurrence relation

- $x_{i+1} = Ax_{i} + B \pmod{M} \quad \quad$ need $\gcd(A, M) = 1$

### Running Example

For this example we have $x_0 = 2134, A = 4381, B = 7364, M = 8397$

$$x_{n+1} = 4381 x_n + 7364 \pmod{8397}$$

We decode $x_0 = 2134$ into $(21, 34)$ and view letters as 2 digit numbers $\pmod{20}$ and do column addition $\pmod{10}$

The first few values of $x_n$ are

- $x_0 = 2134$
- $x_1 = 2160$
- $x_2 = 6905$
- $x_3 = 3778$

| Syntax | Description |
| --- | ----------- |
| Header | Title |
| Paragraph | Text |

| Text-Letter | S | E | C | R | E | T |
| ----------- | - | - | - | - | - | - |
| Text-Digits | 19 | 05 | 03 | 18 | 05 | 20 |
| Key-Digits | 21 | 60 | 69 | 05 | 37 | 78 |
| Ciphertext | 30 | 65 | 62 | 13 | 32 | 98 |

To decode

| Bob Wants | $m_{1, 1} m_{1, 2}$ | $m_{2, 1} m_{2, 2}$ | $m_{3, 1} m_{3, 2}$ | 
| ----------- | - | - | - | - | - | - |
| Bob Knows Key | 21 | 60 | 62 | 
| Bob Sees | 30 | 65 | 62 |

Thus Bob can deduce $m_{i, j}$

- $m_{1, 1} + 2 \equiv 3 \implies m_{1, 1} \equiv 3 - 2 \equiv 1$
- $m_{1, 2} + 1 \equiv 0 \implies m_{1, 2} \equiv -1 \equiv 9$
- Thus the first letter is $19 = S$

### Cracking LCG

Assume that Eve knows that $A, B, M$ are all $4$ digits and that the document contains the word "Pakistan". So Eve looks at each $8$ sequence of letters and tests it. Suppose Eve tests the sequence $(24, 66, 87, 47, 17, 45, 26 , 96)$


| Text-Letter | P | A | K | I | S | T | A | N |
| ----------- | - | - | - | - | - | - | - | - |
| Text-Digits | 16 | 01 | 11 | 09 | 19 | 20 | 01 | 14 |
| Key-Digits | $k_{11} k_{12}$ | $k_{21} k_{22}$ | $k_{31} k_{32}$ | $k_{41} k_{42}$ | $k_{51} k_{52}$ | $k_{61} k_{62}$ | $k_{71} k_{72}$ | $k_{81} k_{82}$ | 
| Ciphertext | 24 | 66 | 87 | 47 | 17 | 45 | 26 | 96 |

Eve guesses that the key digits are $(18, 65, 76, 48, 08, 25, 25, 82)$ and is able to create the formulas

$$7648 = 1865A + B \pmod{M}$$
$$825 \equiv 7648 A + B \pmod{M}$$
$$2582 \equiv 825A + B \pmod{M}$$

Using some arithmetic, we can find the values of $A, B, M$

- **Note** $7649 \leq M \leq 9999$ since $M$ is $4$ digits long and $\gcd(A, M) = 1$

After finding $A, B, M$, Eve can recursively solve for $x_0$

Finally, after finding $x_0, A, B, M$ still needs to recover the entire plaintext and test IS-ENGLISH. If it fails, then Eve needs to test the next sequence

## Matrix Cipher
Pick an $n \times n$ matrix $M$

Enc $x \rightarrow M(x)$

Dec $x \rightarrow M^{-1}(y)$

- **Note**: $M$ must be invertible
- Easy for Alice and Bob to use since $M$ is small and it's easy to find $M^{-1}$
- Hard for Eve to brute force since key space is $\approx 26^{n^2}$


**Brute Force Algorithm for n = 8 $(O(26^{64}))$**
```
for every 8 * 8 matrix M in Z_{26}:
  test if M is invertible
  decode T into T'
  if IS-ENGLISH(T')
    return M
```

**Better Algorithm for n = 8 $(O(8*26^8))$**

Let $T = t_1 t_2 \ldots t_N$ where $t_i = t_i^1 \ldots t_i^8$

Note that $MT_i = m_i \implies R_j t_i = m^j_i$

```
for i = 1 to 8
  for r in Z^{8}_{26}
    T' = (r * t_1, ... r *t_N)
    if IS-ENGLISH(T')
      r_i = r
      goto next i
```
## Other Ciphers

### Autokey Cipher
Idea is to use part of the plaintext as key after a start

Key is a short phrase (e.g. "Metz" = (12, 4, 19, 25))

- Shift first letter by 12
- Shift second letter by 4
- Shift third letter by 19
- Shift fourth letter by 25
- Afterwards use the plaintext for shift, lagged by 4

### Book Cipher

Use an agreed book as the key and then for each word in the message, specify

- Page number
- Line number
- Word number

## Random Shift
Idea of this cipher is to ensure that the same two messages don't get mapped to the same ciphertext

Key is a function (e.g. $f(r) = 2r + y$). To encrypt "NYNY"

- Pick a random $r = 4$ so first shift is $2 * 4 + 7 = 15$
- Pick a random $r = 10$ so second shift is $2 * 10 + 7 = 1$
- Pick a random $r = 1$ so third shift is $2 * 1 + 7 = 9$
- Pick a random $r = 17$ so fourth shift is $2 * 17 + 7 = 15$
- Send $(4; c)$, $(10; Z)$, $(1;W)$, $(17; N)$

### Chebyshev's Inequality

We want to know how likely does $X$ differ a lot from $E(X)$

- We have $N$ balls uniformly distributed over $n$ bins
- Let $X_r$ be the number of balls in bin $R$. We expect $E(X_r) = N/n$

$\Pr(|X - E(X)| \geq k\sigma \leq 1/k^2$ where $\sigma = \sqrt{V(X)}$

Thus the probability that all $r \in \{1, \ldots, 26\}$ appear $\geq N/26$ is $\geq 0.999999999$

So we can assume that each $r$ appears a lot

### Cracking Random Shift

Eve sees

$$(r_1; \sigma_1) \ldots (r_N; \sigma_N)$$

- There are only 26 possible $r$
- There are $N$ pairs of $(r_i, \sigma_i)$
- Some pair has to appear $L = N/26$ times by pigeon hole property

$$(r; \sigma_{i_1}) \ldots (r; \sigma_{i_L})$$

Are coded up using the same $r$. We can do frequency analysis on these values to solve for a particular $r$. The same method can be done for all $r$ since by **Chebyshev's Inequality** there is a large probability that all $r$'s appear a lot of times.

**Algorithm**
```
for r in {1, ..., 26}
  look at the stream of σ with the same r. These σ's will have the same shift
  Guess each shift using IS-ENGLISH
We now have mappings of r to shifts and can decode
```

## Math for Public Key Encryption

### Exponentiation

Input: $a,n, p$

Output: $a^n \pmod{p}$

Algorithm Idea:

- Convert the exponent into binary
- Use repeated squaring : $x^1, x^2, x^4, \ldots$
- Then $x^n = x^{n_1} * x^{n_2} * \cdots$. Where $n_1, n_2, \ldots$ are powers of $2$

### Generator for $Z_p^*$

For a prime $p$ and $\{g^1, \ldots, g^{p-1}\} = \{1, \ldots, p-1\}$, $g$ is a **generator** for $Z_p^*$

**Theorem**: if $g$ is NOT a generator, then there exists $x$ such that

- $x \mid p-1$
- $x \neq p - 1$
- $g^x \equiv 1$

Finding Generators Algorithm:

```
Input p
Let F be the set of factors of p-1, except p - 1
For g in p/3 to 2p/3:
  Compute g^x for all x in F. If any give 1, then g is NOT a generator
  Otherwise if none of them give 1 for g, then output g
```

However, factoring is thought to be hard, so we can extend the algorithm for only **safe primes** 

where $p$ and $p-1 = 2q$ for a prime $q$. This way $F = \{2, q\}$ which is easy to check

### Discrete Log Problem

Input: $g, a, p \quad 1 \leq g, a \leq p - 1 \quad \langle g \rangle = Z_p^*$

Output $x$ such that $g^x \equiv a \pmod{p}$

In general, we have $g \in \{p/3 \ldots, 2p/3\}$

$$DL_{p, g}(y) = x \text{ such that } g^x \equiv y \pmod{p}$$

The problem is suspected to be hard for $g, a \in \{p/3, \ldots, 2p/3\}$. Although there are some tricks:

- If $g$ is a generator of $Z_p^*$ then $g^{(p-1)/2} \equiv p - 1 \equiv -1$
- **Example**: $3^x \equiv 92 \pmod{101} \implies 92 \equiv 101 - 9 \equiv (-1)3^2 \equiv 3^{50} * 3^2 \equiv 3^{52}$

A good algorithm would solve this problem in $O(\log(n))$

### Primality Testing

**Fermat's Little Theorem**: given a prime $p$, $a^p \equiv a \pmod{p}$

Algorithm:

```
Input p
Choose a random subset R of {2, ..., p-1} of size lg(p)
For each a in R, compute a^p and if not equivalent to a, then p is NOT prime
```

### Generating Same Primes of length $L$

```
Input L
Pick y in {0, 1}^{L-1}
Let x = 1y
Test if x is a prime and (x-1)/2 is a prime
If both are prime then output x, else goto step 2
```

Can be extended to remove multiples of $2$ and $3$.

- $2$ doesn't divide $n \iff (\exists k)[n = 2k + 1]$
- $3$ doesn't divide $n \iff (\exists k, \exists i \in \{1, 2\})[n = 3k + i]$
- Thus $2, 3$ don't divide $n \iff (\exists k, \exists i \in \{1, 5\})[n = 6k + i]$


## Diffie Hellman

Given a security param $L$

1. Alice finds $(p, g)$ such that len$(p) = L$
2. Alice sends $(p, g)$ to Bob (Eve sees this)
3. Alice picks random $a$ and sends $g^a \pmod{p}$ to Bob (Eve sees this)
4. Bob picks random $b$ and sends $g^b \pmod{p}$ to Alice (Eve see this)
5. Alice computes $(g^b)^a = g^{ab}$
6. Bob computes $(g^a)^b = g^{ab}$

$g^{ab}$ is the **shared secret** and it believed that it is hard for Eve to find $g^{ab}$

### El Gamal

1. Alice and Bob do Diffie Hellman
2. Alice and Bob share $s = g^{ab} \pmod{p}$
3. Alice and Bob compute $s^{-1} \pmod{p}$
4. Enc$(m) = c = ms \pmod{p}$
5. Dec$(c) = cs^{1} = mss^{-1} = m \pmod{p}$

## RSA

### Initial Math

Recall **Fermat's Little Theorem**: for prime $p$,

- $a^p \equiv a \pmod{p}$
- $a^{p-1} \equiv 1 \pmod{p}$ given $a \neq 0$

Then we have $a^m \equiv a^{m \pmod{p-1}} \pmod{p}$. Example showing why this works

$11^{999,999,999} \pmod{107}$

By Fermat's Little Theorem, we have $11^{106} \equiv 1 \pmod{107}$ and we have $999, 999, 999 \equiv 27 \pmod{106}$

Thus $11^{999,999,999} \equiv (11^{106})^k \times 11^{27} \equiv 11^{27} \pmod{107}$

Generalized formula: $a^m \equiv a^{k(p-1)} + r \equiv a^r$

Since $r \equiv m \pmod{p-1}$, we have that $a^m \equiv a^{m \pmod{p -1}} \pmod{p}$

**Important**: for $n$ relative prime to $a$, we have that 

$$a^m \equiv a^{m \pmod{\phi(n)}} \pmod{n}$$

**Example**: $14^{999,999} \pmod{393}$

Note that $\phi(393) = \phi(3) \phi(131) = 2 * 130 = 260$

Thus $14^{999,999} \equiv 14^{999,999 \pmod{260}} \equiv 14^{39} \pmod{393}$

### RSA Steps

1. Alice picks 2 primes $p, q$ of length $L$ and computes $N = pq$
2. Alice computes $R = \phi(N) = \phi(pq) = (p-1)(q-1)$
3. Alice picks $e \in \{R/3, \ldots, 2R/3\}$ that is relatively prime to $R$
4. Alice finds $d$ such that $ed \equiv 1 \pmod{R}$
5. Alice broadcasts $(N, e)$ so that both Bob and Eve can see it
6. Bob wants to send $m \in \{1, \ldots, N-1\}$ and broadcasts $m^e \pmod{N}$
7. Alice receives $m^e \pmod{N}$ and computes

$$(m^e)^d \equiv m^{ed} \equiv m^{ed \pmod{R}} \equiv m \pmod{N}$$

## Jevon's Number

$J = 8, 616, 460, 799$

Idea is that $J = x^2 - y^2 = (x-y)(x+y)$. We use $J \equiv 99 \equiv -1 \pmod{100}$ to show that

$x^2 + 1 = y^2 \pmod{100}$ then calculation shows that the only relevant pairs are $(0,0)$ and $(24, 25)$

- $x^2 = 0 \implies x \in \{10, 20, \ldots, 90\}$
- $x^2 = 24 \implies x \in \{18, 32, 68, 82\}$

Thus $x = 92880, y = 3199$

## Birthday Paradox

Probability that no boxes has $\geq 2$ balls

- Number of ways to put balls $m$ balls into $n$ boxes is $n^m$
- Number of ways to put balls into boxes such that no box has $\geq 2$ balls is $n(n-1)\cdots(n-m+1)$

Thus Probability that no boxes has $\geq 2$ balls is

$$P = \frac{n(n-1) \cdots (n-m+1)}{n^m} = 1(1 - \frac{1}{n})(1 - \frac{2}{n}) \cdots (1 - \frac{m-1}{n})$$

Which is $\approx e^{-m^2/2n}$

It's use is that we need $\approx n^{1/2}$ balls to put at least $2$ balls in each box. Thus probability that $2$ balls are in the same box is large

## Pollard's $\rho$ Algorithm

We want to factor $N$. We know that $p$ is a factor of $N$ and $p \leq N^{1/2}$. Idea is to find $x, y$ such that $x \equiv y \pmod{p}$

- $\gcd(x-y, N)$ will yield a nontrivial factor of $N$ since $p$ divides both
- Idea is to pick random $x_1 \in \{1, \ldots, N-1\}$ and generate $x_i = x_{i-1} * x_{i-1} + c \pmod{N}$
- Idea is that $x_i = x_j$, then $x_{i + 1} = x_{j + a}$, so we find $k$ such that $x_k \equiv x_{2k}$

```
define f(x) = x * x + c

x  = rand(1, N-1),  c = rand(1, N-1),   y = f(x)
while TRUE:
  x = f(x)
  y = f(f(y))
  d = gcd(x - y, N)
  if d != 1 and d != N
    break
output(d)
```

## Low e Attack on RSA

### Chinese Remainder Theorem

If $N_1, \ldots, N_l$ are relatively prime then there exists $0 \leq x < N_1 \cdots N_L$ such that

$x \equiv x_1 \pmod{N_1}$

$x \equiv x_2 \pmod{N_2}$

$\cdots$

$x \equiv x_2 \pmod{N_2}$

### e Theorem

Instead of $x_1, x_2, \ldots, x_n$, we can look at $m^e \pmod{N_i}$. Then find an $x$ such that $0 \leq x < N_1 \cdots N_L$

Finally we have that $x$ is the $e$th power of $m$

## Same $N$ Attack on RSA

**Definition**: A set of numbers if **relatively prime** if no number divides all of them

**Theorem**: If $a, b, c$ are rel prime, then there exists $x_1, x_2, x_3$ such that $ax_1 + bx_2 + cx_3 = 1$

Analysis of generalization of $L$. Zelda sends $m$ to $A_1, \ldots, A_L$ and Eve sees $m^{e_i}$

* $e_1, \ldots, e_L$ are rel prime so there exists $x_1, \ldots, x_L$ such that $\displaystyle \sum_{i = 1}^L e_ix_i = 1$
* Eve finds such $x_1, \ldots, x_l$ and computes

$$(m^{e_1})^{x_1} \times \cdots \times (m^{e_L})^{x_L} = m^{\sum_{i = 1}^L e_ix_i} \equiv m^1 \equiv m \pmod{N}$$

## Learn with Errors Private Key

### Cipher Idea

- Alice and Bob have a private key. Example $(170, 39, 3, 1)$
- They also have a prime public key. Example $191$ 
- If Alice picks $4$ random numbers - example $(40, 28, 111, 7)$ - and takes the dot product. Answer here is $19$

    - If Alice wants to send $0$, she sends $((40, 28, 111, 7; 19)$
    - If Alice wants to send $1$, she sends $((40, 28, 111, 7; 20)$

- Bob receives the message and computes dot product

    - If Bob's result is $19$, then $b = 0$
    - If Bob's result is $20$, then $b = 1$

Eve can crack this by using Known Plaintext Attack

- Eve later finds out later that Alice's previous message of $(40, 28, 111, 7; 19)$ had $b = 0$

    - So we have $40 k_1 + 28k_2 + 111 k_3 + 7k_4 \equiv 19 \pmod{191}$
    - Repeating this for other messages cuts down search space

### Generalized Cipher

Let $e \in^r A$ mean that $e$ is picked uniformly randomly from the set $A$

Let $\frac{p}{4}$ denote $\lfloor \frac{p}{4} \rfloor$ for $p$ odd

Let $\vec{k}$ denote the key and $\vec{r}$ denote a random vector

Let $\gamma$ be a parameter such that we choose $e$ from $\{-\gamma, \ldots, \gamma\}$

&nbsp;

Private key $\vec{k}$

Public info $p, \gamma$

1. Alice picks a random vector $\vec{r}$
2. Alice computes $\vec{r} \cdot \vec{k} \equiv C \pmod{p}$ and chooses $e \in^r \{-\gamma, \ldots, \gamma\}$
3. Let $D \equiv C + e + \frac{bp}{4}$
4. To send $b$, Alice sends $(\vec{r}; D)$
5. Bob computes $\vec{r} \cdot \vec{k} \equiv C$ 

    - $D \approx C \implies b = 0$ (within $\gamma$)
    - $D \approx C + \frac{p}{4} \implies b = 1$ (within $\gamma$)
    - Otherwise Eve tampered the message

&nbsp;

Also need to pick $\gamma$ such that it works

- If $b = 0$, Bob compares $C$ to $C + e$ ($e \in \{-\gamma, \ldots, \gamma$)
- If $b = 1$, Bob compares $C$ to $C + e + \frac{p}{4}$ ($e \in \{-\gamma + \frac{p}{4}, \ldots, \gamma + \frac{p}{4}\}$)

So we need these to intervals (with wrap around) to be disjoint

Choosing $\gamma < \frac{p}{16}$ suffices since $2\gamma < \frac{p}{4}$ and $2\gamma + \frac{p}{4} < p$

&nbsp;

**Learning with Errors Problem**: given $p, \gamma$ and tuples of $(\vec{r}, D)$ and told that $\vec{r} \cdot \vec{k} - D \equiv e \in^r \{-\gamma, \ldots, \gamma\}$, how easily can you solve the equations?

## Learn with Errors Public Key


### Cipher Idea

Idea is for only Alice to have the key vector $\vec{k}$ and have Alice publish several noisy equations that satifsfy $\vec{k}$. For $e_i \in^r \{-\gamma, \gamma\}$

$$\vec{r} \cdot \vec{k} \sim C_1 + e_1$$

$$\vec{s} \cdot \vec{k} \sim C_2 + e_2$$

$$\ldots$$

Taking the sum $(r_1 + s_1) x_1 + \cdots + (r_n + s_n) \sim C_1 + C_2 + e_1 + e_2$ so error in $\{-2\gamma, \ldots, 2\gamma\}$

### Example

Let $p = 4, n = 4, e \in^4 \{-1, 0, 1\}$

Alice wants bob to be able to send $b \in \{0, 1\}$ and picks random key $\vec{k} = (1, 10, 21, 89)$

Alice also picks 4 random $\vec{r}$s with $e_i$

$(4, 9, 1, 89), e_1 = 1$

$(9, 98, 9, 1), e_2 = -1$

$(44, 55, 10, 8), e_2 = 0$

$(9, 3, 11, 99), e_2 = 1$

- **Note**: any sum of equations has $(1, 10, 21, 89)$ as an "answer"

Alice broadcasts these $4$ equations

To send bit $b = 0$, Bob picks 2 equations and adds them together

- Eve sees the equations but doesn't know which equations were added together

- Alice finds that $\vec{k}$ yields an answer close to the solution so $b = 0$

To send bit $b=1$, Bob picks 2 equations, adds them together, and also adds $50$ to the solution

- Alice finds that $\vec{k}$ yields an answer NOT close to the solution so $b = 1$

### Generalized Cipher

Public information: $p, \gamma,n, m$

Alice wants Bob to be able to send $b \in \{0, 1\}$

1. Alice picks a random $\vec{k}$ of length $n$

2. Alice picks $m$ random $\vec{r}$, each with their own $e \in^r \{-\gamma, \ldots, \gamma\}$

  - Let $D = \vec{r} \cdot \vec{k} + e$
3. Alice broadcasts each $(\vec{r}; D)$

  - **Note**: $\vec{k}$ satisfies noisy equations and any sum of them

4. Bob wants to send bit $b$ and picks a random uniform set of noisy equations, adds them, and adds $bp/2$ to the solution. Let $D'$ be the sum of all $D$s in the selected equations

    $s_1 x_1 + \cdots + s_nx_n \sim D' + bp/2$ if and only if $b = 0$
5. Bob broadcasts $(\vec{s}; F = D' + bp/2)$

6. Alice computes $\vec{s} \cdot \vec{k} - F$

    - If small then $b = 0$
    - If large then $b = 1$

## Psuedo Random

No such that as a truly random bit string. Instead we pick a bit string uniformly on $\{0, 1\}^n$.

  - Each string has probability of being chosen of $\frac{1}{2^n}$

**Psuedorandom Generator (PRG)**: expands a short seed into a longer string that looks random. The question now becomes, if the result looks random

### PRG Game

Let $p$ be a polynomial and $G: \{0, 1\}^n \rightarrow \{0, 1\}^{p(n)}$ be computable in poly time

1. Alice picks $x \in \{0, 1\}^n$ uniformly and computes $y = G(x) \in \{0, 1\}^{p(n)}$
2. Alice picks $z \in \{0, 1\}^{p(n)}$ uniformly
3. Alice gives $\{w_1, w_2\} = \{y, z\}$ to Eve ($z$ is either $w_1$ or $w_2$
4. Eve outputs one of $\{w_1, w_2\}$ hoping it's $z$
5. If Eve outputs $z$, she wings

Can Eve win this game with probability $\geq 1/2$? Depends on how much Computational Power Eve has

**Eve Strategy under Unlimited Computational Power**

1. Eve gets $w_1, w_z$ as input (one of which is $z$)
2. Eve creates the set $A = \{G(x) \mid x \in \{0, 1\}^n\}$. This takes exponential time
3. If $w_1 \notin A$, then Eve outputs $w_1$ and wins
4. If $w_2 \notin A$, then Eve outputs $w_2$ and wins
5. If $w_1, w_2 \in A$, then Eve outputs $w_1$, though she might be wrong
    - Probability of Eve losing is $\leq$ probability that $z \in A$.
    - There are $2^{p(n)}$ that $z$ could be, of which $2^n$ are in $A$.
    - Thus probability that Eve loses is $\leq \displaystyle \frac{2^n}{2^{p(n)}} < 1/2$

  However, we restrict Eve to having only polynomial computing time

### PRG Formal

A function $f: Z^+ \rightarrow [0, 1]$ is **negligible** if for every polynomial $p$ and for large $n$, $f(n) < \frac{1}{p(n)}$

  - **Example**: $f(n) = \frac{1}{2^n}$

An algorithm is **Poly Prob Time (PPT)** if there is a randomized algorithm that halts it in poly time and has a negligible probability of error

  - **Example**: Primality

**Definition**: $F$ is a **PRG** if for all **PPT**, there is a negligible function $\epsilon(n)$ such that

$$\Pr[\text{Eve Wins}] \leq \frac{1}{2} + \epsilon(n)$$

### Candidate for PRG

1. Input $b \in \{0, 1\}^n$
2. Find $p$, the first safe prime $\geq b$
3. Find $g$, the smallest generator of $Z_p^*$
4. Compute $(g^1, g^2, \ldots, g^{n^2})$, all mod $p$. View these results as $n$-bit strings
5. Let $b_i$ be the right most bit of $g^i$
6. Output $b_1 b_2 \cdots b_{n^2}$

### Psuedo One Time Pad

Let $G$ be a PRG from $\{0, 1\}^n$ to $\{0, 1\}^{p(n)}$

1. Alice generates an $n$-bit string $k$ with $n$ truly random bits
2. Alice computes $G(k) = k'$, creating $p(n)$ psuedo-random bits
3. Alice and Bob use $k'$ for their one-time pad

## Stream Ciphers

**Stream Cipher** is a recurrence that generates bits. Pair of efficient, deterministic algorithms (Init, GetBits) such that

- Init does: Input a private seed $s$ (truly random) and outputs $y_0, y_1, \ldots, y_n$ for some $n$
- GetBits does: Input $y_0, \ldots, y_m$ and Outputs the bit $y_{m+1}$

These 2 functions can generate any desired number of output bits from an initial seed

A stream cipher is considered secure if the output generated from a uniform seed is psuedorandom (formal definition is based on the psuedorandom game)

### Linear Feedback Shift Registers

Degree 3 LFSR uses

- $+$ is $\mod{2}$
- 3 constants: $c_0, c_1, c_2 \in \{0, 1\}$
- Key 3 bits: $(y_0, y_1, y_2)$

$$y_{t + 1} = c_2 y_{t - 3} + c_1 y_{t - 2} + c_0 y_{t - 1}$$

- This recurrence is eventually periodic. For $n$-degree, max periodicity is $2^n - 1$

Also LFSR is NOT SECURE

- For degree $3$, we have $c_0, c_1, c_2$ unknown and $y_1, y_2, \ldots, y_6$ known. Then

$y_4 = c_2 y_3 + c_1 y_2 + c_0 y_1$

$y_5 = c_2 y_4 + c_1 y_3 + c_0 y_2$

$y_6 = c_2 y_5 + c_1 y_4 + c_0 y_3$

Thus $3$ linear equations and $3$ variables can be solved

  - Takes $2n$ iterations to crack

### Nonlinear Feedback Shift Registers (NFSR)

Adds nonlinearity to prevent attacks

Let $n$ be even and $+$ be under $\mod{2}$

Initialize $x_1, x_2, x_3, x_4$. Then we have

$$x_{n+1} = x_n x_{n-1} + x_{n-1}x_{n-2} + x_{n-3}x_{n-4}$$

PAGE %$57$ CONTINUE

## Threshold Secret Sharing

Zelda has a secret $s \in \{0, 1\}^n$

**(t, m)-secret sharing** is a way for Zelda to give strings to $A_1, \ldots, A_m$ such that 

- If any $t$ get together, they can learn $s$
- If any $< t$ get together, they cannot learn anything

**Random String Approach**: ($(4, 4)$ case) Zelda generates random $r_1, r_2,r_3 \in \{0, 1\}^n$ and

- Gives $A_1$ $s_1 = r_1$
- Gives $A_2$ $s_2 = r_2$
- Gives $A_3$ $s_3 = r_3$
- Gives $A_4$ $s_4 = s \oplus r_1 \oplus r_2 \oplus r_3$

$A_1, A_2, A_3, A_4$ can recover the secret by doing $s_1 \oplus s_2 \oplus s_3 \oplus s_4 = s$

### Generalized (t,m)-Secret Sharing

Given a secret $s \in \{0, 1\}^n$

For each $t$-set of $A_1, \ldots, A_m$, create random strings so that they can recover the secret if they all get together.

Note for $(m/2, m)$, $A_i$ gets about $\frac{2^m}{\sqrt{m}}$ strings.

To reduce the number of strings, look below

### Threshold Secret Sharing with Polynomials (t,m)

We can imagine a secret will always be an element of $Z_p$ for prime $p$

- $s = 20 \implies Z_{23}$
- $s = 23 \implies Z_{23} \implies s = 0$

Zelda wants to send a string to $A_1, \ldots, A_m$ such that

- Any $t$ of $A_1, \ldots, A_m$ can find $s$
- Any $< 1$ learn nothing

1. $s \in Z_p$ and Zelda works under mod $p$
2. Zelda generates random numbers $a_{t-1}, \ldots, a_1 \in Z_p$
3. Zelda creates the polynomial $f(x) = a_{t-1}x^{t-1} + \cdots + a_1x + s$
4. For $1 \leq i \leq m$, Zelda gives each $A_i$ $f(i)$ (all mod $p$)
    - Any $t$ people have $t$ points from $f(x)$ and can solve for $s$
    - Any $<t$ people don't have enough information to figure out $s$

### Length of Shares

For random-string method (domain $\{0, 1\}^n$), Zelda MUST send shares of length $|s|$

**Example**: $(4,5)$ secret sharing scheme with Zelda sharing $s$ of length $7$.

- There are $2^7 = 128$ possibilities for $s$
- Consider $A_5$ gets a share of length $6$. We show that the scheme is NOT info-theoretic secure
- Then $A_1, A_2, A_3$ can learn something

    - Let CAND = $\emptyset$ be the set of Candidates for $s$
    - For $x \in \{0, 1\}^6$ (go through all shares $A_5$ could have)
    - However this reduces the search space since $2^ < 2^7$. Thus $A_1, A_2, A_3$ have eliminated many strings from being the secret $s$

### Length of Shares under Computational Security

Under info-theoretic security, length of shares must be $\geq |s|$

However, we can assume that there is a hardness problem so we look for length of shares $\beta n$

**General Problem**: Players $A_1, \ldots, A_m$ and secret $s$

1. If $\geq t$ of them get together, they can find $s$
2. If $< t$ og them get together, they cannot find $s$

This can be generalized. Let $X$ (**access structure**) be the set of all subsets of $\{A_1, \ldots, A_m\}$ with $\geq t$ players

1. If $Y \in X$ then players in $Y$ can find $s$
2. if $Y \notin X$ then players in $Y$ cannot find $s$

Secret sharing scheme is **ideal** if all shares come from the same domain as the secret.

### OR Ideal Secret Sharing

We want a group that can find the secret share $s$ if either

- at least 2 of $A_1, A_2, A_3$ OR
- at least 4 of $B_1, B_2, B_3, B_4, B_5, B_6, B_7$

Zelda can does this by doing (2,3) secret sharing with $A_1, A_2, A_3$ and (4,7) secret sharing with $B_1, B_2, B_3, B_4, B_5, B_6, B_7$

This notation can be simplified to $TH_A(t_1, m_1) \vee TH_B(t_2, m_2)$

Can be generalized to $TH_A(t_1, m_1) \vee \cdots \vee TH_B(t_{26}, m_{26})$

### AND Ideal Secret Sharing

Similar to Disjoint Ideal Secret Sharing except now it is generalized to

$TH_A(t_1, m_1) \wedge \cdots \wedge TH_B(t_{26}, m_{26})$

1. Zelda has secret $s$, $|s| = n$
2. Zelda generates random $r_1, \ldots, r_{25} \in \{0, 1\}^n$
3. Zelda does $(t_1, m_1)$ secret sharing of $r_1$ with $A_i$'s
4. $\ldots$
5. Zelda does $(t_{25}, m_{25})$ secret sharing of $r_{25}$ with $Y_i$'s
6. Zelda does $(t_{26}, m_{26})$ secret sharing of $r_1 \oplus \cdots \oplus r_{25} \oplus s$ with $Z_i$'s
7. If $\geq t_1$ of $A_i$'s get together they can find $r_1$. Similar for $B_i, \ldots Y_i$. Finally, if $\geq t_{26}$ of $Z_i$'s get together they can find $r_1 \oplus \cdots \oplus r_{25} \oplus s$ so together, all groups can find $s$

### General Theorem

A **monotone formula** is a Boolean formula with no NOT signs. Using ideas from $TH$, we get

**Theorem**: Let $X_1, \ldots, X_n$ each be a threshold $TH_A(t, m)$ but all using different players

Let $F(X_1, \ldots, X_N)$ be a monotone Boolean formula where each $X_i$ appears only once. Then Zelda can do ideal secret sharing where only sets that satisfy $F(X_1, \ldots, X_N)$ can learn the secret
