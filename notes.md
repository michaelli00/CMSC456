## Overview

Alice wants to send a message to Bob

- Eve overhears the message
- Adam and Bob don't want Eve to be able to decode it

**Information-Theoretic Security**: Eve doesn't have enough information to crack the message, even with unlimited computation power

**Computation Security**: Eve is computationally limited (e.g. can't factor quickly)

Steps for any cipher

- Remove spaces and make blocks of $5$ characters
- Make all letters capital
- Remove punctuation
- Can extend alphabet to accept numbers

## Modular Arithmetic (Abbreviated)

$x \equiv y \pmod{n}$ if and only if $n \mid x - y$

Modular division: we want a number such that $xy \equiv 1 \pmod n$

  - Will only exist if $x, y$ are coprime

## Shift Cipher

$M$ = all English texts, **Message Space**

$S$ = $\{0, \ldots, 25\}$, **Key Space**

Enc$(M, s) = (m_1 + s, m_2 + s, \ldots)$

Dec$(C, s) = (c_1 - s, c_2 - s, \ldots)$

### Cracking Shift Cipher

One thing to note is that Shift has a **small keyspace** so we can brute force all 26 keys

```
Input T
For s = 0 to 25
  Generate T + s
  Look at result and test if it looks English
```

However, this is extremely tedious. Instead we use **letter frequencies**

Let $T$ be a long text of length $N$

Let $N_a$ be the number of $a \in T$, $N_b$ be the number of $b \in T, \ldots$

We define a frequency vector $f_T = (\frac{N_a}{N}, \frac{N_b}{N}, \ldots, \frac{N_z}{N})$ and define the following algorithm:

**IsEnglish**

Let $f_E$ be the frequency vector of English

Let $f_T$ be the frequency vector of $T$

Note that taking the dot product, only $f_E \cdot f_E$ will be large $(\approx 0065)$, and all other dot products will be small $(\approx 0.038)$

```
Input T
Compute f_T
Compute f_E⋅f_T and if ~ 0.065 YES else NO
```

Turning back to cracking shift, the overall algorithm is

```
Input T
For s = 0 to 25
  Create T_s
  If IsEnglish(T_s) = YES then STOP
```

## Kerkhoff's Principle
We assume that

- Eve knows the encryption scheme
- Eve knows the alphabet and language
- Eve doesn't know the key
- Key is chosen randomly

## Private Key Encryption

$M$ is the message space

Generate a key $k \in K$

Enc(m)

Dec(m)

**Note**: we must have that $(\forall m \in M)$[Dec(Enc($m$)) = $m$]

## Affine Cipher

$K = \{(a,b) \mid 0 \leq a, b \leq 25 \text{ and } a \text{ rel prime 26}|\}$

Encrypt: $x \rightarrow ax +b \pmod{26}$

Decyrpt: $x \rightarrow a^{-1}(x - b) \pmod{26}$

Only requirement is that we need $\gcd(a, 26) = 1$ so that $a^{-1}$ exists

### Cracking Affine Cipher

```
Input T, a long English text
For all (a,b) in K:
  Apply ax + b to T and obtain T_{a,b}
  Let f_{a,b} be the frequency vector of T_{a,b}
  Compute f_E⋅f_{a,b}
The answer will the (a,b) pair that maximizes the dot product
```

## Quadratic Cipher

$K = \{(a, b, c) \mid 0 \leq a,b,c \leq 25\}$

Encrypt: $x \rightarrow ax^2 + bx + c$

Main issue is that we need to ensure that $f(x)$, with $a,b,c$ has an inverse, but this is hard b/c we need to test each individual $f(0) \ldots f(25)$

## General Sub Cipher and Random Looking Cipher
Idea is to take a permutation of $\{0, \ldots, 25\}$ as the key

Enc: $x \rightarrow f(x)$

Dec: $x \rightarrow f^{-1}(x)$

### Random Looking Cipher (Keyword Shift Cipher)

Generating a completely random permutation can be difficult, so instead we want to create a random looking permutation

For **Keyword Shift Cipher**, the key is (phrase, shift)

The permutation is generated by 
  - writing out phrase (removing duplicate letters)
  - horizontally shifting the text by `shift`

Main concern is that for a small phrase, there are a long sequence of consecutive letters

### Cracking General Substitution

Let $\sigma$ be a permutation and $T$ be a text

- $f_E$ is the frequency of $n$-grams, a $26^n$ long vector
- $\sigma(T)$ is taking $T$ and applying $\sigma$ to it
- $f_{\sigma(T)}$ is a $26^n$ frequency vector for $\sigma(T)$
- Use $I, R$ as parameters
- We compare permutations $\sigma_i$ and $\sigma_j$ by seeing which one looks more like English

```
Let σ_{init} be a permutation that maps 'e' to the most frequent letter

for r = 1 to R (small)
  σ_r = σ_{init}
  for i = 1 to I (large)
    pick j, k in {0, ..., 25} random
    let σ' be σ_r with j, k swapped
    if f_{σ'} produces a better frequency than f_{σ}
      σ_r = σ'
pick σ_r with the best result and have a human look at σ_r(T)
```

## Vigenere Cipher
Key is a word or phrase: $k = (k_1, k_2, \ldots, k_n)$

Enc$(m, k)$ = $m_1 + k_1, \ldots, m_n + k_{n}, m_{k+1} + k_1 \ldots$

Enc$(c, k)$ = $c_1 - k_1, \ldots, c_n - k_{n}, c_{k+1} - k_1 \ldots$

There are 3 main types of vig ciphers:

- Standard: key is a short phrase
- Book: use an entire book as the key
- One time pad: extremely long set of random bits that can't be exhausted

### Cracking Vigenere Cipher
First we find the length of the key $L$. We assume that a word that appears frequently will likely appear in the same position $i \pmod{L}$

- For example is "aiq" appears in the slots (57, 58, 59), (87, 88, 89), (102, 103, 104), (162, 163, 164), we can deduce that the length of the key is a divisor of the gaps between these sequences, $L = \{1, 3, 5, 15\}$

This will create a stream of every $L$th character. We can do shift analysis on these streams

### One Time Pad
We encode messages with a long string of random bits

$M = \{0, 1\}^n$

Gen $K = \{0, 1\}^n$

Enc$(m,k) = k \oplus m$

Dec $(c, k) = k \oplus k$

## Psuedo Random Bits
Creating pure random bits is hard for One Time Pad. Instead we produce a string a random looking bits using **Linear Congruential Generator**

Pick $M$ large and $A, B, x_0$ that are random looking. Then we can create a recurrence relation

$$x_{i+1} = Ax_{i} + B \pmod{M}$$

- **Note**: we need $\gcd(A, M) = 1$

### Running Example

For this example we have $x_0 = 2134, A = 4381, B = 7364, M = 8397$

$$x_{n+1} = 4381 x_n + 7364 \pmod{8397}$$

We decode $x_0 = 2134$ into $(21, 34)$ and view letters as 2 digit numbers $\pmod{20}$ and do column addition $\pmod{10}$

The first few values of $x_n$ are

- $x_0 = 2134$
- $x_1 = 2160$
- $x_2 = 6905$
- $x_3 = 3778$

| Syntax | Description |
| --- | ----------- |
| Header | Title |
| Paragraph | Text |

| Text-Letter | S | E | C | R | E | T |
| ----------- | - | - | - | - | - | - |
| Text-Digits | 19 | 05 | 03 | 18 | 05 | 20 |
| Key-Digits | 21 | 60 | 69 | 05 | 37 | 78 |
| Ciphertext | 30 | 65 | 62 | 13 | 32 | 98 |

To decode

| Bob Wants | $m_{1, 1} m_{1, 2}$ | $m_{2, 1} m_{2, 2}$ | $m_{3, 1} m_{3, 2}$ | 
| ----------- | - | - | - | - | - | - |
| Bob Knows Key | 21 | 60 | 62 | 
| Bob Sees | 30 | 65 | 62 |

Thus Bob can deduce $m_{i, j}$

- $m_{1, 1} + 2 \equiv 3 \implies m_{1, 1} \equiv 3 - 2 \equiv 1$
- $m_{1, 2} + 1 \equiv 0 \implies m_{1, 2} \equiv -1 \equiv 9$
- Thus the first letter is $19 = S$

### Cracking LCG

Assume that Eve knows that $A, B, M$ are all $4$ digits and that the document contains the word "Pakistan". So Eve looks at each $8$ sequence of letters and tests it. Suppose Eve tests the sequence $(24, 66, 87, 47, 17, 45, 26 , 96)$


| Text-Letter | P | A | K | I | S | T | A | N |
| ----------- | - | - | - | - | - | - | - | - |
| Text-Digits | 16 | 01 | 11 | 09 | 19 | 20 | 01 | 14 |
| Key-Digits | $k_{11} k_{12}$ | $k_{21} k_{22}$ | $k_{31} k_{32}$ | $k_{41} k_{42}$ | $k_{51} k_{52}$ | $k_{61} k_{62}$ | $k_{71} k_{72}$ | $k_{81} k_{82}$ | 
| Ciphertext | 24 | 66 | 87 | 47 | 17 | 45 | 26 | 96 |

Eve guesses that the key digits are $(18, 65, 76, 48, 08, 25, 25, 82)$ and is able to create the formulas

$$7648 = 1865A + B \pmod{M}$$
$$825 \equiv 7648 A + B \pmod{M}$$
$$2582 \equiv 825A + B \pmod{M}$$

Using some arithmetic, we can find the values of $A, B, M$

- **Note** $7649 \leq M \leq 9999$ since $M$ is $4$ digits long and $\gcd(A, M) = 1$

After finding $A, B, M$, Eve can recursively solve for $x_0$

Finally, after finding $x_0, A, B, M$ still needs to recover the entire plaintext and test IS-ENGLISH. If it fails, then Eve needs to test the next sequence

## Matrix Cipher
Pick an $n \times n$ matrix $M$

Enc $x \rightarrow M(x)$

Dec $x \rightarrow M^{-1}(y)$

- **Note**: $M$ must be invertible
- Easy for Alice and Bob to use since $M$ is small and it's easy to find $M^{-1}$
- Hard for Eve to brute force since key space is $\approx 26^{n^2}$


**Brute Force Algorithm for n = 8 $(O(26^{64}))$**
```
for every 8 * 8 matrix M in Z_{26}:
  test if M is invertible
  decode T into T'
  if IS-ENGLISH(T')
    return M
```

**Better Algorithm for n = 8 $(O(8*26^8))$**

Let $T = t_1 t_2 \ldots t_N$ where $t_i = t_i^1 \ldots t_i^8$

Note that $MT_i = m_i \implies R_j t_i = m^j_i$

```
for i = 1 to 8
  for r in Z^{8}_{26}
    T' = (r * t_1, ... r *t_N)
    if IS-ENGLISH(T')
      r_i = r
      goto next i
```
## Other Ciphers

### Autokey Cipher
Idea is to use part of the plaintext as key after a start

Key is a short phrase (e.g. "Metz" = (12, 4, 19, 25))

- Shift first letter by 12
- Shift second letter by 4
- Shift third letter by 19
- Shift fourth letter by 25
- Afterwards use the plaintext for shift, lagged by 4

### Book Cipher

Use an agreed book as the key and then for each word in the message, specify

- Page number
- Line number
- Word number

## Random Shift
Idea of this cipher is to ensure that the same two messages don't get mapped to the same ciphertext

Key is a function (e.g. $f(r) = 2r + y$). To encrypt "NYNY"

- Pick a random $r = 4$ so first shift is $2 * 4 + 7 = 15$
- Pick a random $r = 10$ so second shift is $2 * 10 + 7 = 1$
- Pick a random $r = 1$ so third shift is $2 * 1 + 7 = 9$
- Pick a random $r = 17$ so fourth shift is $2 * 17 + 7 = 15$
- Send $(4; c)$, $(10; Z)$, $(1;W)$, $(17; N)$

### Chebyshev's Inequality

We want to know how likely does $X$ differ a lot from $E(X)$

- We have $N$ balls uniformly distributed over $n$ bins
- Let $X_r$ be the number of balls in bin $R$. We expect $E(X_r) = N/n$

$\Pr(|X - E(X)| \geq k\sigma \leq 1/k^2$ where $\sigma = \sqrt{V(X)}$

Thus the probability that all $r \in \{1, \ldots, 26\}$ appear $\geq N/26$ is $\geq 0.999999999$

So we can assume that each $r$ appears a lot

### Cracking Random Shift

Eve sees

$$(r_1; \sigma_1) \ldots (r_N; \sigma_N)$$

- There are only 26 possible $r$
- There are $N$ pairs of $(r_i, \sigma_i)$
- Some pair has to appear $L = N/26$ times by pigeon hole property

$$(r; \sigma_{i_1}) \ldots (r; \sigma_{i_L})$$

Are coded up using the same $r$. We can do frequency analysis on these values to solve for a particular $r$. The same method can be done for all $r$ since by **Chebyshev's Inequality** there is a large probability that all $r$'s appear a lot of times.

**Algorithm**
```
for r in {1, ..., 26}
  look at the stream of σ with the same r. These σ's will have the same shift
  Guess each shift using IS-ENGLISH
We now have mappings of r to shifts and can decode
```

## Math for Public Key Encryption

### Exponentiation

Input: $a,n, p$

Output: $a^n \pmod{p}$

Algorithm Idea:

- Convert the exponent into binary
- Use repeated squaring : $x^1, x^2, x^4, \ldots$
- Then $x^n = x^{n_1} * x^{n_2} * \cdots$. Where $n_1, n_2, \ldots$ are powers of $2$

### Generator for $Z_p^*$

For a prime $p$ and $\{g^1, \ldots, g^{p-1}\} = \{1, \ldots, p-1\}$, $g$ is a **generator** for $Z_p^*$

**Theorem**: if $g$ is NOT a generator, then there exists $x$ such that

- $x \mid p-1$
- $x \neq p - 1$
- $g^x \equiv 1$

Finding Generators Algorithm:

```
Input p
Let F be the set of factors of p-1, except p - 1
For g in p/3 to 2p/3:
  Compute g^x for all x in F. If any give 1, then g is NOT a generator
  Otherwise if none of them give 1 for g, then output g
```

However, factoring is thought to be hard, so we can extend the algorithm for only **safe primes** 

where $p$ and $p-1 = 2q$ for a prime $q$. This way $F = \{2, q\}$ which is easy to check

### Discrete Log Problem

Input: $g, a, p \quad 1 \leq g, a \leq p - 1 \quad \langle g \rangle = Z_p^*$

Output $x$ such that $g^x \equiv a \pmod{p}$

In general, we have $g \in \{p/3 \ldots, 2p/3\}$

$$DL_{p, g}(y) = x \text{ such that } g^x \equiv y \pmod{p}$$

The problem is suspected to be hard for $g, a \in \{p/3, \ldots, 2p/3\}$. Although there are some tricks:

- If $g$ is a generator of $Z_p^*$ then $g^{(p-1)/2)} \equiv p - 1 \equiv -1$
- **Example**: $3^x \equiv 92 \pmod{101} \implies 92 \equiv 101 - 9 \equiv (-1)3^2 \equiv 3^{50} * 3^2 \equiv 3^{52}$

A good algorithm would solve this problem in $O(\log(n))$

### Primality Testing

**Fermat's Little Theorem**: given a prime $p$, $a^p \equiv a \pmod{p}$

Algorithm:

```
Input p
Choose a random subset R of {2, ..., p-1} of size lg(p)
For each a in R, compute a^p and if not equivalent to a, then p is NOT prime
```

### Generating Same Primes of length $L$

```
Input L
Pick y in {0, 1}^{L-1}
Let x = 1y
Test if x is a prime and (x-1)/2 is a prime
If both are prime then output x, else goto step 2
```

Can be extended to remove multiples of $2$ and $3$.

- $2$ doesn't divide $n \iff (\exists k)[n = 2k + 1]$
- $3$ doesn't divide $n \iff (\exists k, \exists i \in \{1, 2\})[n = 3k + i]$
- Thus $2, 3$ don't divide $n \iff (\exists k, \exists i \in \{1, 5\})[n = 6k + i]$


## Diffie Hellman

Given a security param $L$

1. Alice finds $(p, g)$ such that len$(p) = L$
2. Alice sends $(p, g)$ to Bob (Eve sees this)
3. Alice picks random $a$ and sends $g^a \pmod{p}$ to Bob (Eve sees this)
4. Bob picks random $b$ and sends $g^b \pmod{p}$ to Alice (Eve see this)
5. Alice computes $(g^b)^a = g^{ab}$
6. Bob computes $(g^a)^b = g^{ab}$

$g^{ab}$ is the **shared secret** and it believed that it is hard for Eve to find $g^{ab}$

### El Gamal

1. Alice and Bob do Diffie Hellman
2. Alice and Bob share $s = g^{ab} \pmod{p}$
3. Alice and Bob compute $s^{-1} \pmod{p}$
4. Enc$(m) = c = ms \pmod{p}$
5. Dec$(c) = cs^{1} = mss^{-1} = m \pmod{p}$

## RSA

### Initial Math

Recall **Fermat's Little Theorem**: for prime $p$,

- $a^p \equiv a \pmod{p}$
- $a^{p-1} \equiv 1 \pmod{p}$ given $a \neq 0$

Then we have $a^m \equiv a^{m \pmod{p-1}} \pmod{p}$. Example showing why this works

$11^{999,999,999} \pmod{107}$

By Fermat's Little Theorem, we have $11^{106} \equiv 1 \pmod{107}$ and we have $999, 999, 999 \equiv 27 \pmod{106}$

Thus $11^{999,999,999} \equiv (11^{106})^k \times 11^{27} \equiv 11^{27} \pmod{107}$

Generalized formula: $a^m \equiv a^{k(p-1)} + r \equiv a^r$

Since $r \equiv m \pmod{p-1}$, we have that $a^m \equiv a^{m \pmod{p -1}} \pmod{p}$

**Important**: for $n$ relative prime to $a$, we have that 

$$a^m \equiv a^{m \pmod{\phi(n)}} \pmod{n}$$

**Example**: $14^{999,999} \pmod{393}$

Note that $\phi(393) = \phi(3) \phi(131) = 2 * 130 = 260$

Thus $14^{999,999} \equiv 14^{999,999 \pmod{260}} \equiv 14^{39} \pmod{393}$

### RSA Steps

1. Alice picks 2 primes $p, q$ of length $L$ and computes $N = pq$
2. Alice computes $R = \phi(N) = \phi(pq) = (p-1)(q-1)$
3. Alice picks $e \in \{R/3, \ldots, 2R/3\}$ that is relatively prime to $R$
4. Alice finds $d$ such that $ed \equiv 1 \pmod{R}$
5. Alice broadcasts $(N, e)$ so that both Bob and Eve can see it
6. Bob wants to send $m \in \{1, \ldots, N-1\}$ and broadcasts $m^e \pmod{N}$
7. Alice receives $m^e \pmod{N}$ and computes

$$(m^e)^d \equiv m^{ed} \equiv m^{ed \pmod{R}} \equiv m \pmod{N}$$
